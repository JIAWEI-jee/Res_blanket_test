C51 COMPILER V9.56.0.0   ADC                                                               11/16/2020 18:59:00 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Objects\adc.obj
COMPILER INVOKED BY: C:\program_list\keil\C51\BIN\C51.EXE ..\Device\adc\adc.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\D
                    -evice\LED;..\Device\system_digital_tube;..\Device\BEEP;..\Device\timer;..\Device\key;..\Device\uart;..\Device\adc) DEBUG
                    - OBJECTEXTEND PRINT(.\Listings\adc.lst) TABS(2) OBJECT(.\Objects\adc.obj)

line level    source

   1          #include "adc.h"
   2          #include "uart.h"
   3          #include "system_digital_tube.h"
   4          #include "key.h"
   5          #include "LED.h"
   6          #include "Beep.h"
   7          
   8          
   9          //const u16 SKU_RES_Table = [];
  10          
  11          void delay_us ( u16 us ) //16MHz
  12          {
  13   1        while ( --us )
  14   1        {
  15   2          _nop_();
  16   2          _nop_();
  17   2        }
  18   1      }
  19          
  20          void ADC_Init_Config ( void )
  21          {
  22   1        P0M0 = 0x01;    //P00设置为模拟输入
  23   1        P0M1 = 0x01;        //P01设置为模拟输入
  24   1        P0M2 = 0x01;    //P02设置为模拟输入
  25   1        P0M3 = 0x01;        //P03设置为模拟输入
  26   1      
  27   1        P2M6 = 0XC1;        //设置P26推挽输出
  28   1        P2M7 = 0XC1;        //设置P27推挽输出
  29   1        ADCC0 = 0x81;   //打开ADC转换电源     00 VDD
  30   1      //                      01 内部4V
  31   1      //                      10 内部3V
  32   1      //                      11 内部2V
  33   1      //1、 内部参考电压选择为 2V 时， VDD 电压须高于 2.7V；
  34   1      //    内部参考电压选择为 3V 时， VDD 电压须高于 3.5V；
  35   1      //    内部参考电压选择为 4V 时， VDD 电压须高于4.5V。
  36   1      //2、 系统进入掉电模式前，建议将 ADC 参考电压选择非 VDD，可以进一步降低系统
             -功耗。
  37   1        delay_us ( 20 );            //延时20us，确保ADC系统稳定
  38   1        ADCC2 = 0x4B;           //转换结果12位数据，数据右对齐，ADC时钟16分频 16M/16 = 1MHz
  39   1        RT_0 = 1;
  40   1        RT_1 = 1;
  41   1      }
  42          
  43          static u16 get_adc_val_ch0 ( void )
  44          {
  45   1        u16 adc_val = 0;
  46   1        ADCC1 = 0x00;                   //CH0
  47   1      
  48   1        ADCC0 |= 0x40;          //启动ADC转换
  49   1        while ( ! ( ADCC0&0x20 ) );     //等待ADC转换结束
  50   1        ADCC0 &=~ 0x20;         //清除标志位
  51   1        adc_val = ADCR;         //获取ADC的值
  52   1        delay_us ( 20 );
C51 COMPILER V9.56.0.0   ADC                                                               11/16/2020 18:59:00 PAGE 2   

  53   1        return adc_val;
  54   1      }
  55          
  56          static u16 get_adc_val_ch1 ( void )
  57          {
  58   1        u16 adc_val = 0;
  59   1        ADCC1 = 0x01;                   //CH1
  60   1      
  61   1        ADCC0 |= 0x40;          //启动ADC转换
  62   1        while ( ! ( ADCC0&0x20 ) );     //等待ADC转换结束
  63   1        ADCC0 &=~ 0x20;         //清除标志位
  64   1      
  65   1        adc_val = ADCR;         //获取ADC的值
  66   1      
  67   1        delay_us ( 20 );
  68   1        // ADC_printf("P01_ADC = %d \r\n",adc_val);
  69   1        return adc_val;
  70   1      }
  71          
  72          static u16 get_adc_val_ch2 ( void )
  73          {
  74   1        u16 adc_val = 0;
  75   1        ADCC1 = 0x02;                   //CH2
  76   1      
  77   1        ADCC0 |= 0x40;          //启动ADC转换
  78   1        while ( ! ( ADCC0&0x20 ) );     //等待ADC转换结束
  79   1        ADCC0 &=~ 0x20;         //清除标志位
  80   1        adc_val = ADCR;         //获取ADC的值
  81   1        delay_us ( 20 );
  82   1        return adc_val;
  83   1      }
  84          
  85          static u16 get_adc_val_ch3 ( void )
  86          {
  87   1        u16 adc_val = 0;
  88   1        ADCC1 = 0x03;                   //CH3
  89   1      
  90   1        ADCC0 |= 0x40;          //启动ADC转换
  91   1        while ( ! ( ADCC0&0x20 ) );     //等待ADC转换结束
  92   1        ADCC0 &=~ 0x20;         //清除标志位
  93   1        adc_val = ADCR;         //获取ADC的值
  94   1        delay_us ( 20 );
  95   1        // ADC_printf("P01_ADC = %d \r\n",adc_val);
  96   1        return adc_val;
  97   1      }
  98          
  99          static void get_ADC_value_ch02ch3 ( u16* ch0_value,u16* ch1_value,u16* ch2_value,u16* ch3_value )
 100          {
 101   1      
 102   1        *ch0_value = get_adc_val_ch0 ();
 103   1        *ch1_value = get_adc_val_ch1 ();
 104   1        *ch2_value = get_adc_val_ch2 ();
 105   1        *ch3_value = get_adc_val_ch3 ();
 106   1      }
 107          
 108          
 109          static void Voltg_calc ( u16* ch0_v,u16* ch1_v,u16* ch2_v,u16* ch3_v )
 110          {
 111   1        u16 ch0_ad_value = 0,ch1_ad_value = 0,ch2_ad_value = 0,ch3_ad_value = 0;
 112   1        float temp = 0;
 113   1        get_ADC_value_ch02ch3 ( &ch0_ad_value,&ch1_ad_value,&ch2_ad_value,&ch3_ad_value );
 114   1      //   ADC_printf ( "ch0_ad = %d ch1_ad = %d ch2_ad = %d ch3_ad = %d \r\n",ch0_ad_value,ch1_ad_value,ch2_ad_
C51 COMPILER V9.56.0.0   ADC                                                               11/16/2020 18:59:00 PAGE 3   

             -value,ch3_ad_value ); //pjw set
 115   1      //  ADC_printf ( "adv0 = %d \r\n",ch0_ad_value ); //pjw set
 116   1        temp = ( float ) ch0_ad_value/4095*ADC_CAILI;
 117   1      //  KEY_printf ( "adv0f = %f \r\n",temp ); //pjw set
 118   1        * ch0_v = ( u16 ) temp;
 119   1      //  KEY_printf ( "rtemper1 = %d \r\n",*ch0_v ); //pjw set
 120   1      
 121   1        temp = 0;
 122   1      //  ADC_printf ( "adv1 = %d \r\n",ch1_ad_value ); //pjw set
 123   1        temp = ( float ) ch1_ad_value/4095;
 124   1      //  KEY_printf ( "adv1_temp = %f \r\n",temp ); //pjw set
 125   1        temp = temp*ADC_CAILI;
 126   1        * ch1_v = ( u16 ) temp;
 127   1      //  KEY_printf ( "rtemper2 = %d \r\n",*ch1_v ); //pjw set
 128   1      
 129   1        temp = 0;
 130   1      //  ADC_printf ( "adv2 = %d \r\n",ch2_ad_value ); //pjw set
 131   1        temp = ( float ) ch2_ad_value/4095*ADC_CAILI;
 132   1      //  KEY_printf ( "adv2f = %f \r\n",temp ); //pjw set
 133   1        * ch2_v = ( u16 ) temp;
 134   1      //  KEY_printf ( "heat1 = %d \r\n",*ch2_v ); //pjw set
 135   1      
 136   1        temp = 0;
 137   1      //  ADC_printf ( "adv3 = %d \r\n",ch3_ad_value ); //pjw set
 138   1        temp = ( float ) ch3_ad_value/4095*ADC_CAILI;
 139   1      //  KEY_printf ( "adv3f = %f \r\n",temp ); //pjw set
 140   1        * ch3_v = ( u16 ) temp;
 141   1      //  KEY_printf ( "heat2 = %d \r\n",*ch3_v ); //pjw set
 142   1      
 143   1      }
 144          
 145          void Cacl_Res ( u16* temper_res,u16* heat_res )
 146          {
 147   1        float temp =0,res = 0;
 148   1        u16 ch0 = 0,ch1 = 0,ch2 = 0,ch3 = 0;
 149   1        Voltg_calc ( &ch0,&ch1,&ch2,&ch3 );
 150   1      //  ADC_printf ( "ch0 = %d ch1 = %d ch2 = %d ch3 = %d \r\n",ch0,ch1,ch2,ch3 ); //pjw set
 151   1        temp = (  ( ( float ) ch0 /1000 ) - ( ( float ) ch1/1000 ) ) / ( ( ( float ) ch1/1000 ) /510 );
 152   1        ADC_printf ( "temper_res = %f \r\n",temp ); //pjw set
 153   1        *temper_res = ( u16 ) temp;
 154   1      //  ADC_printf ( "temper_res = %d \r\n",* temper_res ); //pjw set
 155   1      
 156   1      
 157   1        temp = (  ( ( float ) ch2 /1000 ) - ( ( float ) ch3/1000 ) ) / ( ( ( float ) ch3/1000 ) /510 );
 158   1        ADC_printf ( "heat_res = %f \r\n",temp ); //pjw set
 159   1        *heat_res = ( u16 ) temp;
 160   1      //  ADC_printf ( "heat_res = %d \r\n",* heat_res ); //pjw set
 161   1      }
 162          u8 SKU_Res_test ( void )
 163          {
 164   1        u16 Temper_res = 0,Heat_res = 0;
 165   1        Cacl_Res ( &Temper_res,&Heat_res );
 166   1        switch ( tube_num.SKU_std )
 167   1        {
 168   2          case K9011:
 169   2          case K9019:
 170   2          case K9029:
 171   2            case K9014:
 172   2            if ( ( Temper_res > K9011_MIN_TEMPER ) && ( Temper_res < K9011_MAX_TEMPER ) )
 173   2            {
 174   3              if ( ( Heat_res >K9011_MIN_HEAT ) && ( Heat_res < K9011_MAX_HEAT ) )
 175   3              {
C51 COMPILER V9.56.0.0   ADC                                                               11/16/2020 18:59:00 PAGE 4   

 176   4                return Res_test_OK;
 177   4              }
 178   3              else
 179   3              {
 180   4                return Heat_test_fail;
 181   4              }
 182   3            }
 183   2            else
 184   2            {
 185   3              return Temper_test_fail;
 186   3            }
 187   2            break;
 188   2          case K9018:
 189   2          case K9025:
 190   2            if ( ( Temper_res > K9018_MIN_TEMPER ) && ( Temper_res < K9018_MAX_TEMPER ) )
 191   2            {
 192   3              if ( ( Heat_res > K9018_MIN_HEAT ) && ( Heat_res < K9018_MAX_HEAT ) )
 193   3              {
 194   4                return Res_test_OK;
 195   4              }
 196   3              else
 197   3              {
 198   4                return Heat_test_fail;
 199   4              }
 200   3            }
 201   2            else
 202   2            {
 203   3              return Temper_test_fail;
 204   3            }
 205   2            break;
 206   2          case K9028:
 207   2            if ( ( Temper_res > K9028_MIN_TEMPER ) && ( Temper_res < K9028_MAX_TEMPER ) )
 208   2            {
 209   3              if ( ( Heat_res > K9028_MIN_HEAT ) && ( Heat_res < K9028_MAX_HEAT ) )
 210   3              {
 211   4                return Res_test_OK;
 212   4              }
 213   3              else
 214   3              {
 215   4                return Heat_test_fail;
 216   4              }
 217   3            }
 218   2            else
 219   2            {
 220   3              return Temper_test_fail;
 221   3            }
 222   2            break;
 223   2          case K9017:
 224   2            if ( ( Temper_res > K9017_MIN_HEAT ) && ( Temper_res < K9017_MAX_TEMPER ) )
 225   2            {
 226   3              if ( ( Heat_res > K9017_MIN_HEAT ) && ( Heat_res < K9017_MAX_HEAT ) )
 227   3              {
 228   4                return Res_test_OK;
 229   4              }
 230   3              else
 231   3              {
 232   4                return Heat_test_fail;
 233   4              }
 234   3            }
 235   2            else
 236   2            {
 237   3              return Temper_test_fail;
C51 COMPILER V9.56.0.0   ADC                                                               11/16/2020 18:59:00 PAGE 5   

 238   3            }
 239   2            break;
 240   2            case K8104:
 241   2            case K8105: 
 242   2            if ( ( Temper_res > K8104_MIN_HEAT ) && ( Temper_res < K8104_MAX_TEMPER ) )
 243   2            {
 244   3              if ( ( Heat_res > K8104_MIN_HEAT ) && ( Heat_res < K8104_MAX_HEAT ) )
 245   3              {
 246   4                return Res_test_OK;
 247   4              }
 248   3              else
 249   3              {
 250   4                return Heat_test_fail;
 251   4              }
 252   3            }
 253   2            else
 254   2            {
 255   3              return Temper_test_fail;
 256   3            }
 257   2            break;
 258   2        }
 259   1        
 260   1      }
 261          void Blanket_Cacl_Process ( void )
 262          {
 263   1        u8 blank_test_std = 0;
 264   1        blank_test_std = SKU_Res_test ();
 265   1      
 266   1        switch(blank_test_std)
 267   1          {
 268   2           case Res_test_OK:
 269   2          LED1 = 0;
 270   2          LED0 = 1;
 271   2            beep.beep_std = BEEP_OK;
 272   2          beep.beep_std_of = 1;
 273   2        break;
 274   2         case Temper_test_fail:
 275   2         case Heat_test_fail:
 276   2          LED1 = 1;
 277   2            LED0 = 0;
 278   2            beep.beep_std = BEEP_ERROR;
 279   2          beep.beep_std_of = 1;
 280   2        break;
 281   2          }
 282   1      
 283   1      
 284   1      }
 285          
 286          
*** WARNING C291 IN LINE 260 OF ..\Device\adc\adc.c: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1531    ----
   CONSTANT SIZE    =     36    ----
   XDATA SIZE       =   ----      62
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)

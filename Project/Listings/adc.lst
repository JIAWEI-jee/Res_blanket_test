C51 COMPILER V9.56.0.0   ADC                                                               12/07/2020 17:39:23 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Objects\adc.obj
COMPILER INVOKED BY: C:\program_list\keil\C51\BIN\C51.EXE ..\Device\adc\adc.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\D
                    -evice\LED;..\Device\system_digital_tube;..\Device\BEEP;..\Device\timer;..\Device\key;..\Device\uart;..\Device\adc) DEBUG
                    - OBJECTEXTEND PRINT(.\Listings\adc.lst) OBJECT(.\Objects\adc.obj)

line level    source

   1          #include "adc.h"
   2          #include "uart.h"
   3          #include "system_digital_tube.h"
   4          #include "key.h"
   5          #include "LED.h"
   6          #include "Beep.h"
   7          
   8          
   9          //const u16 SKU_RES_Table = [];
  10          
  11          u16 systick_2min = 0;
  12          
  13          
  14          void delay_us ( u16 us ) //16MHz
  15          {
  16   1              while ( --us )
  17   1              {
  18   2                      _nop_();
  19   2                      _nop_();
  20   2              }
  21   1      }
  22          
  23          void ADC_Init_Config ( void )
  24          {
  25   1              P0M0 = 0x01;            //P00设置为模拟输入
  26   1              P0M1 = 0x01;        //P01设置为模拟输入
  27   1              P0M2 = 0x01;            //P02设置为模拟输入
  28   1              P0M3 = 0x01;        //P03设置为模拟输入
  29   1      
  30   1              P3M5 = 0XC1;        //设置P35推挽输出
  31   1              P2M5 = 0XC1;        //设置P25推挽输出
  32   1              ADCC0 = 0x81;           //打开ADC转换电源                 00 VDD
  33   1      //                                                                                      01 内部4V
  34   1      //                                                                                      10 内部3V
  35   1      //                                                                                      11 内部2V
  36   1      //1、 内部参考电压选择为 2V 时， VDD 电压须高于 2.7V；
  37   1      //    内部参考电压选择为 3V 时， VDD 电压须高于 3.5V；
  38   1      //    内部参考电压选择为 4V 时， VDD 电压须高于4.5V。
  39   1      //2、 系统进入掉电模式前，建议将 ADC 参考电压选择非 VDD，可以进一步降低系统
             -功耗。
  40   1              delay_us ( 20 );                                                //延时20us，确保ADC系统稳定
  41   1              ADCC2 = 0x4B;                                           //转换结果12位数据，数据右对齐，ADC时钟16分频 16M/16 = 1MHz
  42   1              RT_0 = 1;
  43   1              RT_1 = 1;
  44   1      }
  45          
  46          static u16 get_adc_val_ch0 ( void )
  47          {
  48   1              u16 adc_val = 0;
  49   1              ADCC1 = 0x00;                   //CH0
  50   1      
  51   1              ADCC0 |= 0x40;                                  //启动ADC转换
  52   1              while ( ! ( ADCC0&0x20 ) );                     //等待ADC转换结束
C51 COMPILER V9.56.0.0   ADC                                                               12/07/2020 17:39:23 PAGE 2   

  53   1              ADCC0 &=~ 0x20;                                 //清除标志位
  54   1              adc_val = ADCR;                                 //获取ADC的值
  55   1              delay_us ( 20 );
  56   1              return adc_val;
  57   1      }
  58          
  59          static u16 get_adc_val_ch1 ( void )
  60          {
  61   1              u16 adc_val = 0;
  62   1              ADCC1 = 0x01;                   //CH1
  63   1      
  64   1              ADCC0 |= 0x40;                                  //启动ADC转换
  65   1              while ( ! ( ADCC0&0x20 ) );                     //等待ADC转换结束
  66   1              ADCC0 &=~ 0x20;                                 //清除标志位
  67   1      
  68   1              adc_val = ADCR;                                 //获取ADC的值
  69   1      
  70   1              delay_us ( 20 );
  71   1              // ADC_printf("P01_ADC = %d \r\n",adc_val);
  72   1              return adc_val;
  73   1      }
  74          
  75          static u16 get_adc_val_ch2 ( void )
  76          {
  77   1              u16 adc_val = 0;
  78   1              ADCC1 = 0x02;                   //CH2
  79   1      
  80   1              ADCC0 |= 0x40;                                  //启动ADC转换
  81   1              while ( ! ( ADCC0&0x20 ) );                     //等待ADC转换结束
  82   1              ADCC0 &=~ 0x20;                                 //清除标志位
  83   1              adc_val = ADCR;                                 //获取ADC的值
  84   1              delay_us ( 20 );
  85   1              return adc_val;
  86   1      }
  87          
  88          static u16 get_adc_val_ch3 ( void )
  89          {
  90   1              u16 adc_val = 0;
  91   1              ADCC1 = 0x03;                   //CH3
  92   1      
  93   1              ADCC0 |= 0x40;                                  //启动ADC转换
  94   1              while ( ! ( ADCC0&0x20 ) );                     //等待ADC转换结束
  95   1              ADCC0 &=~ 0x20;                                 //清除标志位
  96   1              adc_val = ADCR;                                 //获取ADC的值
  97   1              delay_us ( 20 );
  98   1              // ADC_printf("P01_ADC = %d \r\n",adc_val);
  99   1              return adc_val;
 100   1      }
 101          
 102          static void get_ADC_value_ch02ch3 ( u16* ch0_value,u16* ch1_value,u16* ch2_value,u16* ch3_value )
 103          {
 104   1              *ch0_value = get_adc_val_ch0 ();
 105   1              *ch1_value = get_adc_val_ch1 ();
 106   1              *ch2_value = get_adc_val_ch2 ();
 107   1              *ch3_value = get_adc_val_ch3 ();
 108   1      }
 109          
 110          
 111          static void Voltg_calc ( u16* ch0_v,u16* ch1_v,u16* ch2_v,u16* ch3_v )
 112          {
 113   1              u16 ch0_ad_value = 0,ch1_ad_value = 0,ch2_ad_value = 0,ch3_ad_value = 0;
 114   1              float temp = 0;
C51 COMPILER V9.56.0.0   ADC                                                               12/07/2020 17:39:23 PAGE 3   

 115   1              get_ADC_value_ch02ch3 ( &ch0_ad_value,&ch1_ad_value,&ch2_ad_value,&ch3_ad_value );
 116   1      //   ADC_printf ( "ch0_ad = %d ch1_ad = %d ch2_ad = %d ch3_ad = %d \r\n",ch0_ad_value,ch1_ad_value,ch2_ad_
             -value,ch3_ad_value ); //pjw set
 117   1      
 118   1              temp = ( float ) ch0_ad_value/4095*ADC_CAILI;
 119   1      //      KEY_printf ( "adv0f = %f \r\n",temp ); //pjw set
 120   1              * ch0_v = ( u16 ) temp;
 121   1      //      KEY_printf ( "rtemper1 = %d \r\n",*ch0_v ); //pjw set
 122   1      
 123   1              temp = 0;
 124   1      
 125   1              temp = ( float ) ch1_ad_value/4095;
 126   1      //      KEY_printf ( "adv1_temp = %f \r\n",temp ); //pjw set
 127   1              temp = temp*ADC_CAILI;
 128   1              * ch1_v = ( u16 ) temp;
 129   1      //      KEY_printf ( "rtemper2 = %d \r\n",*ch1_v ); //pjw set
 130   1      
 131   1              temp = 0;
 132   1      
 133   1              temp = ( float ) ch2_ad_value/4095*ADC_CAILI;
 134   1      //      KEY_printf ( "adv2f = %f \r\n",temp ); //pjw set
 135   1              * ch2_v = ( u16 ) temp;
 136   1      //      KEY_printf ( "heat1 = %d \r\n",*ch2_v ); //pjw set
 137   1      
 138   1              temp = 0;
 139   1      
 140   1              temp = ( float ) ch3_ad_value/4095*ADC_CAILI;
 141   1      //      KEY_printf ( "adv3f = %f \r\n",temp ); //pjw set
 142   1              * ch3_v = ( u16 ) temp;
 143   1      //      KEY_printf ( "heat2 = %d \r\n",*ch3_v ); //pjw set
 144   1      
 145   1      }
 146          
 147          u8 Cacl_Res ( u16* temper_res,u16* heat_res )
 148          {
 149   1              float temp =0,res = 0;
 150   1              u16 ch0 = 0,ch1 = 0,ch2 = 0,ch3 = 0;
 151   1              Voltg_calc ( &ch0,&ch1,&ch2,&ch3 );
 152   1      
 153   1      //      ADC_printf ( "ch0 = %d ch1 = %d ch2 = %d ch3 = %d \r\n",ch0,ch1,ch2,ch3 ); //pjw set
 154   1              if ( ( ch1 < 90 ) || ( ch3 < 90 ) )
 155   1              {
 156   2                      return EORROR;
 157   2              }
 158   1      
 159   1              temp = (  ( ( float ) ch0 /1000 ) - ( ( float ) ch1/1000 ) ) / ( ( ( float ) ch1/1000 ) /510 );
 160   1              ADC_printf ( "temper_res = %f \r\n",temp ); //pjw set
 161   1              *temper_res = ( u16 ) temp;
 162   1      //      ADC_printf ( "temper_res = %d \r\n",* temper_res ); //pjw set
 163   1      
 164   1              temp = (  ( ( float ) ch2 /1000 ) - ( ( float ) ch3/1000 ) ) / ( ( ( float ) ch3/1000 ) /510 );
 165   1              ADC_printf ( "heat_res = %f \r\n",temp ); //pjw set
 166   1              *heat_res = ( u16 ) temp;
 167   1      //      ADC_printf ( "heat_res = %d \r\n",* heat_res ); //pjw set
 168   1      
 169   1              return SUCCESS;
 170   1      }
 171          u8 SKU_Res_test ( void )
 172          {
 173   1              u16 Temper_res = 0,Heat_res = 0;
 174   1              if ( Cacl_Res ( &Temper_res,&Heat_res ) == SUCCESS )
 175   1              {
C51 COMPILER V9.56.0.0   ADC                                                               12/07/2020 17:39:23 PAGE 4   

 176   2                      systick_2min = 0;
 177   2                      switch ( tube_num.SKU_std )
 178   2                      {
 179   3                              case K9011:
 180   3                              case K9019:
 181   3                              case K9029:
 182   3                              case K9014:
 183   3                              case K9045:
 184   3                                      if ( ( Temper_res > K9011_MIN_TEMPER ) && ( Temper_res < K9011_MAX_TEMPER ) )
 185   3                                      {
 186   4                                              if ( ( Heat_res >K9011_MIN_HEAT ) && ( Heat_res < K9011_MAX_HEAT ) )
 187   4                                              {
 188   5                                                      return Res_test_OK;
 189   5                                              }
 190   4                                              else
 191   4                                              {
 192   5                                                      return Heat_test_fail;
 193   5                                              }
 194   4                                      }
 195   3                                      else
 196   3                                      {
 197   4                                              return Temper_test_fail;
 198   4                                      }
 199   3                                      break;
 200   3                              case K9018:
 201   3                              case K9025:
 202   3                                      if ( ( Temper_res > K9018_MIN_TEMPER ) && ( Temper_res < K9018_MAX_TEMPER ) )
 203   3                                      {
 204   4                                              if ( ( Heat_res > K9018_MIN_HEAT ) && ( Heat_res < K9018_MAX_HEAT ) )
 205   4                                              {
 206   5                                                      return Res_test_OK;
 207   5                                              }
 208   4                                              else
 209   4                                              {
 210   5                                                      return Heat_test_fail;
 211   5                                              }
 212   4                                      }
 213   3                                      else
 214   3                                      {
 215   4                                              return Temper_test_fail;
 216   4                                      }
 217   3                                      break;
 218   3                              case K9028:
 219   3                                      if ( ( Temper_res > K9028_MIN_TEMPER ) && ( Temper_res < K9028_MAX_TEMPER ) )
 220   3                                      {
 221   4                                              if ( ( Heat_res > K9028_MIN_HEAT ) && ( Heat_res < K9028_MAX_HEAT ) )
 222   4                                              {
 223   5                                                      return Res_test_OK;
 224   5                                              }
 225   4                                              else
 226   4                                              {
 227   5                                                      return Heat_test_fail;
 228   5                                              }
 229   4                                      }
 230   3                                      else
 231   3                                      {
 232   4                                              return Temper_test_fail;
 233   4                                      }
 234   3                                      break;
 235   3                              case K9017:
 236   3                                      if ( ( Temper_res > K9017_MIN_HEAT ) && ( Temper_res < K9017_MAX_TEMPER ) )
 237   3                                      {
C51 COMPILER V9.56.0.0   ADC                                                               12/07/2020 17:39:23 PAGE 5   

 238   4                                              if ( ( Heat_res > K9017_MIN_HEAT ) && ( Heat_res < K9017_MAX_HEAT ) )
 239   4                                              {
 240   5                                                      return Res_test_OK;
 241   5                                              }
 242   4                                              else
 243   4                                              {
 244   5                                                      return Heat_test_fail;
 245   5                                              }
 246   4                                      }
 247   3                                      else
 248   3                                      {
 249   4                                              return Temper_test_fail;
 250   4                                      }
 251   3                                      break;
 252   3                              case K8104:
 253   3                              case K8105:
 254   3                                      if ( ( Temper_res > K8104_MIN_HEAT ) && ( Temper_res < K8104_MAX_TEMPER ) )
 255   3                                      {
 256   4                                              if ( ( Heat_res > K8104_MIN_HEAT ) && ( Heat_res < K8104_MAX_HEAT ) )
 257   4                                              {
 258   5                                                      return Res_test_OK;
 259   5                                              }
 260   4                                              else
 261   4                                              {
 262   5                                                      return Heat_test_fail;
 263   5                                              }
 264   4                                      }
 265   3                                      else
 266   3                                      {
 267   4                                              return Temper_test_fail;
 268   4                                      }
 269   3                                      break;
 270   3                      }
 271   2              }
 272   1              else
 273   1              {
 274   2                      return No_Blanket;
 275   2              }
 276   1      }
 277          
 278          void Blanket_Cacl_Process ( void )
 279          {
 280   1      
 281   1              if ( tube_num.tube_std ==  OFF )
 282   1              {
 283   2                      LED2 = 1;
 284   2                      LED1 = 1;
 285   2                      LED0 = 1;
 286   2              }
 287   1              else
 288   1              {
 289   2      
 290   2                      switch ( SKU_Res_test () )
 291   2                      {
 292   3                              case Res_test_OK:
 293   3                                      LED1 = 0;
 294   3                                      LED0 = 1;
 295   3                                      LED2 = 1;
 296   3                                      beep.beep_std = BEEP_OK;
 297   3                                      beep.beep_std_of = 1;
 298   3                                      break;
 299   3                              case Temper_test_fail:
C51 COMPILER V9.56.0.0   ADC                                                               12/07/2020 17:39:23 PAGE 6   

 300   3                              case Heat_test_fail:
 301   3                                      LED1 = 1;
 302   3                                      LED2 = 1;
 303   3                                      LED0 = 0;
 304   3                                      beep.beep_std = BEEP_ERROR;
 305   3                                      beep.beep_std_of = 1;
 306   3                                      break;
 307   3                              case No_Blanket:
 308   3                                      LED2 = !LED2;
 309   3                                      LED1 = 1;
 310   3                                      LED0 = 1;
 311   3                                      break;
 312   3                      }
 313   2                      if ( ++systick_2min > TIME2OFF )
 314   2                      {
 315   3                              systick_2min = 0;
 316   3                              tube_num.tube_std = OFF;
 317   3                      }
 318   2              }
 319   1      
 320   1      }
 321          
 322          
*** WARNING C291 IN LINE 276 OF ..\Device\adc\adc.c: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1641    ----
   CONSTANT SIZE    =     36    ----
   XDATA SIZE       =      2      62
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
